---
title: 跨域
date: 2017-07-06 9:48:00
categories:
    - Frontend
tags:
    - Javascript
    - Ajax
    - JSONP
---

当需要访问其他服务器的数据或者前后端分离开发对接数据的时候，我们会碰到跨域问题。那什么是跨域？又该如何解决呢？
<!-- more -->

## 1、什么是跨域
浏览器有个最核心最基本的安全功能 -- 同源策略。同源指的是：域名、协议、端口均相同。否则，浏览器会报错：
```javascript
No 'Access-Control-Allow-Origin'
```
``` javascript
A: 'http://m.luoym.com/article/a.js'
B: 'http://m.luoym.com/product/b.js'
// 允许访问。    同一域名下（不同文件夹）。

A: 'http://m.luoym.com:8080/a.js'
B: 'http://m.luoym.com:8081/b.js'
// 不允许访问。    端口不同。

A: 'http://m.luoym.com/a.js'
B: 'http://116.65.90/b.js'
// 不允许访问。    域名及其对应的ip地址。

A: 'http://m.luoym.com/a.js'
B: 'http://www.luoym.com/b.js'
// 不允许访问。    主域名相同，但子域名不同。

A: 'http://m.luoym.com/a.js'
B: 'http://luoym.com/b.js'
// 不允许访问。    主域名相同，但子域名不同。

A: 'http://m.luoym.com/a.js'
B: 'https://m.luoym.com/b.js'
// 不允许访问。    协议不同。

A: 'http://m.luoym.com/a.js'
B: 'http://m.luoyanming.com/b.js'
// 不允许访问。    域名不同。
```
如果是协议和端口号不同造成的跨域问题，前端是没办法解决的。
`script`、`img`、`iframe` 标签不受同源策略影响。

## 2、解决跨域问题的方法

### (1)、JSONP
用户传递一个 `callback` 给服务端，然后服务端将JSON数据当做参数传入 `callback`，当用户接收到请求响应时，当前页面会调用 `callback` 函数，从而拿到需要的JSON数据。
```javascript
function handleResponse(res) {
    console.log('The response data is': res.data);
}

var script = document.createElement('script');
script.src = 'http://www.luoym.com/news?callback=handleResponse';
document.body.insertBefore(script, document.body.firstChild);

// handleResponse({"people": [{"name":"luoym","age":"28"}]});
```
#### 原理：
1. 我们创建一个 `script` 标签去请求
2. 服务端根据参数 `json` `handleResponse`
3. 生成相应的 `json` 数据 `handleResponse({"people": [{"name":"luoym","age":"28"}]});`
4. 当前页面接收到请求响应的时候，会去执行这个数据
5. 跨域通信完成

#### 注意的点：
1. `JSONP` 只支持 `GET` 请求；
2. `Response Headers` 中的 `Content-Type` 需要指定为 `application/json`;

#### 缺点
1. 不安全，易被篡改页面内容，截获敏感数据

`jQuery Ajax` 写法：
```javascript
$.ajax({
  type: "get", // 指定请求方式
  url: "http://www.luoym.com/news",
  data: {

  },
  dataType: "jsonp", // 指定数据格式 jsonp
  jsonp: "callback", // 指定回调函数
  success: function(res) {

  },
  error: function() {
  
  }
});
```


### (2)、window.name
`window`  对象的 `name` 属性是一个很特别的属性，当该 `window` 的 `location` 变化，然后重新加载，它的 `name` 属性可以依然保持不变。那么我们可以在页面 A 中用 `iframe` 加载其他域的页面 B，而页面 B 中用 `JavaScript` 把需要传递的数据赋值给 `window.name`，`iframe`加载完成之后 `（iframe.onload）`，页面 A 修改 `iframe` 的地址，将其变成同域的一个地址，然后就可以读出 `iframe` 的 `window.name` 的值了（因为 A 中的 `window.name` 和 `iframe` 中的 `window.name` 互相独立的，所以不能直接在 A 中获取 `window.name`，而要通过 `iframe` 获取其 `window.name`）。这个方式非常适合单向的数据请求，而且协议简单、安全。不会像 `JSONP` 那样不做限制地执行外部脚本。

```javascript
// 创建 http://m.luoym.com/a.html
// 创建 http://www.luoym.com/b.html

// a.html
function proxy(url, func) {
  var isFirst = true,
      ifr = document.createElement('iframe'),

  loadFunc = function() {
    if(isFirst) {
      ifr.contentWindow.location = 'http://www.luoym.com/b.html';
      isFirst = false;
    } else {
      func(ifr.contentWindow.name);
      ifr.contentWindow.close();
      document.body.removeChild(ifr);
      ifr.src = '';
      ifr = null;
    }
  };

  ifr.src = url;
  ifr.style.display = 'none';
  if(ifr.attachEvent) {
    ifr.attachEvent('onload', loadFunc);
  } else {
    ifr.onload = loadFunc;
  }

  document.body.appendChild(iframe);
}

proxy('http://www.luoym.com/b.html', function(data){
  console.log(data);
});


// b.html
window.name = '要传送的内容';
```

&nbsp;